[Оглавление](../README.md) > Глава 1. Знакомство с алгоритмами

# Глава 1. Знакомство с алгоритмами

**Алгоритмом** называется набор инструкций для выполнения некоторой задачи.

## Простой поиск

**Простой поиск** — алгоритм поиска элемента в массиве, при котором каждый элемент проверяется по порядку, пока не будет найден нужный элемент или не закончится массив. Этот алгоритм **не требует** сортировки массива.

**Время выполнения**: линейное — O(n) в худшем случае, когда искомый элемент находится в конце массива или отсутствует. 

**Пример простого поиска в массиве**

[Код функции `simpleSearch`](./simple-search.js)
```
function simpleSearch(arr, target) {
  for (let i = 0; i < arr.length; i++) {
    if (arr[i] === target) {
      return i;
    }
  }
  return undefined;
}

const list = [4, 2, 7, 1, 9];

simpleSearch(list, 7); // 2
simpleSearch(list, 5); // undefined
```
---

## Бинарный поиск

**Бинарный поиск** — алгоритм поиска элемента в **отсортированном массиве**. 
Алгоритм работает по принципу «разделяй и властвуй»:
1.	Он делит массив на две части и берет центральный элемент
2.	Сравнивает значение центрального элемента с искомым
3.	Если элемент совпадает — поиск завершён.
4.	Если искомый элемент меньше или больше центрального — отбрасывается левая или правая половина массива.
5.	Процесс повторяется рекурсивно или итеративно, пока элемент не будет найден или область поиска не опустеет.

**Важное условие**: массив значений должен быть отсортирован.

**Время выполнения**: логарифмическое — `O(log n)` в худшем случае, так как каждый шаг сокращает область поиска вдвое.

**Пример бинарного поиска в отсортированном массиве**  

[Код функции `binarySearch`](./binary-search.js)
```
function binarySearch(arr, target) {
  let left = 0;
  let right = arr.length - 1;

  while (left <= right) {
    const mid = Math.floor((left + right) / 2);
    if (arr[mid] === target) {
      return mid;
    } else if (arr[mid] > target) {
      right = mid - 1;
    } else {
      left = mid + 1;
    }
  }
  return undefined;
}

const sortedList = [1, 3, 5, 7, 9];

console.log(binarySearch(sortedList, 1));   // 0
console.log(binarySearch(sortedList, 7));   // 3
console.log(binarySearch(sortedList, -1));  // undefined
```
---

## Время выполнения алгоритма

Нотация **O-большое** описывает, насколько быстро возрастает время выпол­нения алгоритма с увеличением размера входных данных. Обычно рассматривается **худший случай**.

Время выполнения алгоритмов растет с разной скоростью. Чем больше выборка, тем больше разница между линейным и логарифмическим временем.

**Скорость алгоритмов** измеряется не в секундах, а **в темпе роста** количе­ства операций.

---

### `O(log n)` — логарифмическое время

Алгоритм с **логарифмическим временем** выполнения на каждом шаге **уменьшает область поиска в несколько раз** (чаще всего — вдвое).

Каждое сравнение отбрасывает половину массива, поэтому количество операций примерно равно log<sub>2</sub>(n).

Элементов|Попыток
-|-
128|7
1024|10

**Пример**: бинарный поиск.

---

### `O(n)` — линейное время

Алгоритм с **линейным временем** выполнения должен проверить **каждый элемент** входных данных. 

В худшем случае искомый элемент находится в конце массива или отсутствует вовсе, и приходится просмотреть все `n` элементов.

Элементов|Попыток
-|-
100|100
1000|1000

**Пример**: простой поиск.

---

### `O(n * log n)`

Алгоритмы с таким временем выполнения обычно используют принцип «разделяй и властвуй» и применяются к массивам, которые нужно упорядочить.

Такая сложность считается эффективной для сортировки больших наборов данных.

**Пример**: эффективные алгоритмы сортировки (быстрая сортировка).

---

### `O(n²)` — квадратичное время

Алгоритмы с **квадратичным временем** выполнения используют вложенные циклы, из-за чего каждый элемент сравнивается с каждым.

При увеличении размера входных данных время выполнения растёт очень быстро.

**Алгоритмы**: медленные алгоритмы сортировки (сортировка выбором, пузырьковая сортировка).

---

### `O(n!)` — факториальное время

Алгоритмы с **факториальным временем** выполнения перебирают все возможные комбинации элементов.

Даже при небольшом n количество операций становится огромным:

Элементов|Попыток
-|-
5|120
7|5040

**Пример**: очень медленные алгоритмы (задача о коммивояжере: полный перебор).

---

## Задача о коммивояжере
**Условие**:  
Коммивояжер должен объехать все заданные города ровно по одному разу и вернуться в исходный город, выбрав маршрут с минимальной суммарной длиной (или стоимостью).

**Идея решения (полный перебор)**:  
Перебрать все возможные порядки объезда городов, вычислить длину каждого маршрута и выбрать минимальный.

**Сложность**:  
Количество возможных маршрутов равно числу перестановок городов — `n!`, поэтому время выполнения такого алгоритма — **O(n!)**.

**Пример**:  
Для 5 городов существует `5! = 120` возможных маршрутов.  
Для 10 городов — уже `10! = 3 628 800` маршрутов.

**Вывод**:  
Полный перебор подходит только для очень малого количества городов.

---

## Сравнение времени выполнения алгоритмов

| Время выполнения | Характер роста операций | Примеры алгоритмов |
|------------------|------------------------|--------------------|
| **O(log n)**     | Область поиска уменьшается вдвое на каждом шаге | Бинарный поиск |
| **O(n)**         | Количество операций растёт пропорционально размеру данных | Простой поиск |
| **O(n · log n)** | Эффективный рост для больших наборов данных | Быстрая сортировка, сортировка слиянием |
| **O(n²)**        | Квадратичный рост из-за вложенных циклов | Сортировка выбором, пузырьковая сортировка |
| **O(n!)**        | Перебор всех возможных комбинаций | Задача о коммивояжере |