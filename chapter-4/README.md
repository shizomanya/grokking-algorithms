[Оглавление](../README.md) > Глава 4. Быстрая сортировка

# Глава 4. Быстрая сортировка

## Разделяй и властвуй

**«Разделяй и властвуй»** — это общий подход к решению задач, при котором сложная задача разбивается на несколько более мелких, каждая из которых решается отдельно. Результаты затем объединяются, образуя итоговое решение.

**Этапы применения стратегии**:
1.	Определить базовый случай, который можно решить напрямую.
2.	Найти способ разделить задачу на более простые подзадачи, рекурсивно применяя алгоритм к каждой из них.

#### Пример: Алгоритм Евклида

Задача: применяя принцип стратегии "Разделяй и властвуй", найти наибольший общий делитель (НОД) двух чисел c помощью [алгоритма Евклида](./euclidean-algorithm%20/README.md).
- Исходная задача: `gcd(a, b)`
- Подзадача меньшего размера: `gcd(b, a % b)`
- Числа постепенно уменьшаются
- Базовый случай: один из аргументов равен `0`
- Результат: последнее ненулевое значение — это НОД

Таким образом, задача последовательно упрощается, пока не достигнет базового случая.

#### Пример

Фермер имеет прямоугольный участок размером a × b и хочет разделить его на **равные квадратные** участки максимального размера.
- длина участка = `a`
- ширина участка = `b`
- сторона максимального квадрата = НОД(`a, b`)

Эта геометрическая задача напрямую сводится к нахождению НОД для длины и ширины исходного участка.

---

### Работа с массивами

При использовании стратегии "разделяй и властвуй" в работе с массивами, базовым случаем будет:
- пустой массив
- массив из одного элемента

То есть рекурсия продолжается, пока задача не станет настолько простой, что её можно решить напрямую.

[Примеры рекурсивной обработки массивов](./recursive-arrays/README.md)

---

## Быстрая сортировка

Быстрая сортировка (QuickSort) — это алгоритм сортировки, основанный на стратегии «разделяй и властвуй».
Он считается одним из самых эффективных на практике благодаря низкой константе времени выполнения и простоте реализации.

#### Принцип работы быстрой сортировки

1. В исходном массиве выбирается `опорный` элемент
2. Затем массив делится на три части:
  - элементы, которые *меньше* опорного
  - опорный элемент
  - элементы, которые *больше* опорного
3. Далее отсортировать левую и правую часть подмассива

**Базовый случай в быстрой сортировке** - это массив из одного элемента или пустой массив.

Рекурсивное разделение происходит до тех пор, пока не будет достигнут базовый случай.


#### **Пример быстрой сортировки массива**
[Код функции quickSort](./quick-sort.js)
```javascript
function quickSort(arr) {
  // базовый случай
  if (arr.length < 2) {
    return arr;
  }

  // выбираем опорный элемент
  let pivot = arr[0];

  let less = [];
  let greater = [];

  // один проход по массиву, распределяем элементы
  for (let i = 1; i < arr.length; i++) {
    if (arr[i] <= pivot) {
      less.push(arr[i]);
    } else {
      greater.push(arr[i]);
    }
  }
  // рекурсивно сортируем подмассивы
  let sortedLess = quickSort(less);
  let sortedGreater = quickSort(greater);

  // формируем итоговый массив вручную
  let result = [];
  for (let i = 0; i < sortedLess.length; i++) {
    result.push(sortedLess[i]);
  }
  result.push(pivot);
  for (let i = 0; i < sortedGreater.length; i++) {
    result.push(sortedGreater[i]);
  }

  return result;
}

console.log(quickSort([10, 5, 2, 3])); // [2, 3, 5, 10]
```

---

### Эффективность алгоритма

Эффективность алгоритма зависит от выбора `опорного` элемента.

| Случай | Сложность | Комментарий |
|--------|-----------|-------------|
| Худший случай | O(n<sup>2</sup>) | массив уже отсортирован, pivot выбирается плохо, в качестве опорного берется первый элемент |
| Средний случай | O(n log n) | массив уже отсортирован, pivot выбран равномерно, массив делится примерно пополам, в качестве опорного берется средний элемент. |
| Лучший случай | O(n log n) | каждый раз массив делится ровно на 2 |

На каждом шаге алгоритм обращается ко всем элементам массива, независимо от того, как они отсортированы. Поэтому эффективность зависит от высоты стека. В худшем случае высота стека будет равна `n`. В лучшем случае высота стека `log n`, так как каждый раз массив делится на две равные части.
